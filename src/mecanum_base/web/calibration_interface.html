<!DOCTYPE html>
<html lang="it">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Interfaccia Calibrazione Robot</title>

  <!-- Bootstrap -->
  <link rel="stylesheet" href="css/bootstrap.min.css" />
  <script src="js/bootstrap.bundle.min.js"></script>

  <!-- ROSLIB -->
  <script src="js/roslib.min.js"></script>
</head>

<body class="bg-light">
  <div class="container py-4">
    <h2 class="mb-4">ğŸ› ï¸ Interfaccia Calibrazione Robot Mecanum</h2>

    <!-- Procedura guidata -->
    <div class="alert alert-warning">
      <h5>ğŸ“‹ Procedura di calibrazione</h5>
      <ol class="mb-0">
        <li>Seleziona il tipo di test da eseguire (cinematico o PWM).</li>
        <li>Per test cinematici:
          <ul>
            <li>Premi il pulsante di movimento per avviare il test.</li>
            <li>Premi â€œğŸ›‘ Ferma robotâ€ per concludere il test.</li>
            <li>Misura lâ€™errore tra posizione/angolo atteso e reale (in metri o radianti).</li>
            <li>Inserisci lâ€™errore nel campo sottostante.</li>
          </ul>
        </li>
        <li>Per test PWM:
          <ul>
            <li>Inserisci lo step PWM da testare (es. 10).</li>
          </ul>
        </li>
        <li>Premi â€œInvia dati di calibrazioneâ€ per inviare i dati.</li>
      </ol>
    </div>

    <!-- Selettore dispositivo -->
    <div class="mb-3">
      <label for="deviceSelect" class="form-label">Dispositivo da calibrare</label>
      <select class="form-select" id="deviceSelect">
        <option value="mecanum_cmd_node" selected>Ruote</option>
      </select>
    </div>

    <!-- Tipo di test -->
    <div class="mb-3">
      <label for="testType" class="form-label">Tipo di test</label>
      <select class="form-select" id="testType" onchange="updateInstructions()">
        <option value="rettilineo">Rettilineo (errore lungo X)</option>
        <option value="strafe">Strafe (errore lungo Y)</option>
        <option value="rotazione">Rotazione (errore angolare)</option>
        <option value="min_pwm">Impulso minimo (PWM threshold)</option>
        <option value="max_pwm">Impulso massimo sicuro</option>
        <option value="map_pwm">Mappatura impulso â†’ velocitÃ </option>
      </select>
    </div>

    <!-- Istruzioni dinamiche -->
    <div class="mb-3">
      <div id="testInstructions" class="alert alert-info">
        Seleziona un tipo di test per visualizzare le istruzioni.
      </div>
    </div>

    <!-- Comandi di movimento -->
    <div class="mb-4">
      <h5>ğŸ® Comandi di movimento per test cinematici</h5>
      <div class="d-flex flex-wrap gap-2">
        <button class="btn btn-outline-secondary" onclick="sendCmdVel(0.5, 0, 0)">Muovi 1m lungo X</button>
        <button class="btn btn-outline-secondary" onclick="sendCmdVel(0, 0.5, 0)">Muovi 1m lungo Y</button>
        <button class="btn btn-outline-secondary" onclick="sendCmdVel(0, 0, 1.0)">Ruota 180Â°</button>
        <button class="btn btn-outline-danger" onclick="sendCmdVel(0, 0, 0)">ğŸ›‘ Ferma robot</button>
      </div>
    </div>

    <!-- Valore errore -->
    <div class="mb-3">
      <label for="errorValue" class="form-label" id="errorLabel">Errore misurato (m o rad)</label>
      <input type="number" step="0.01" class="form-control" id="errorValue" placeholder="Es. 0.15" />
    </div>

    <!-- Durata del test -->
    <div class="mb-3">
      <label class="form-label">â±ï¸ Durata effettiva del test (secondi)</label>
      <div id="testDuration" class="form-control bg-light">--</div>
    </div>

    <!-- Pulsante invio -->
    <button class="btn btn-primary" onclick="sendCalibration()">Invia dati di calibrazione</button>

    <!-- Output -->
    <div class="mt-4">
      <h5>ğŸ“¡ Messaggi di calibrazione</h5>
      <pre id="calibOutput" class="bg-white border p-3" style="min-height: 150px;"></pre>
    </div>
  </div>

  <script>
    const ros = new ROSLIB.Ros({ url: 'ws://localhost:9091' });

    ros.on('connection', () => console.log('âœ… Connesso a rosbridge'));
    ros.on('error', (error) => console.error('âŒ Errore rosbridge:', error));

    const calibListener = new ROSLIB.Topic({
      ros: ros,
      name: '/calibration_status',
      messageType: 'std_msgs/String'
    });

    calibListener.subscribe((message) => {
      document.getElementById('calibOutput').innerText = message.data;
    });

    let cmdVelInterval = null;
    let startTime = null;     // â±ï¸ Timestamp inizio test
    let testDuration = null;  // â±ï¸ Durata calcolata in secondi

    function updateInstructions() {
      const testType = document.getElementById('testType').value;
      const instructions = document.getElementById('testInstructions');
      const label = document.getElementById('errorLabel');

      if (testType === 'rettilineo') {
        instructions.innerText = 'Fai muovere il robot lungo X per 1 metro. Inserisci lâ€™errore laterale (in metri).';
        label.innerText = 'Errore lungo X (m)';
      } else if (testType === 'strafe') {
        instructions.innerText = 'Fai muovere il robot lateralmente lungo Y per 1 metro. Inserisci lâ€™errore (in metri).';
        label.innerText = 'Errore lungo Y (m)';
      } else if (testType === 'rotazione') {
        instructions.innerText = 'Fai ruotare il robot di 180Â°. Inserisci lâ€™errore angolare (in radianti).';
        label.innerText = 'Errore angolare (rad)';
      } else {
        instructions.innerText = 'Seleziona un tipo di test per visualizzare le istruzioni.';
        label.innerText = 'Valore errore misurato';
      }

      // Reset durata
      document.getElementById('testDuration').innerText = '--';
      testDuration = null;
    }

    function sendCmdVel(vx, vy, wz) {
      const cmdVel = new ROSLIB.Topic({
        ros: ros,
        name: '/cmd_vel',
        messageType: 'geometry_msgs/Twist'
      });

      const twist = new ROSLIB.Message({
        linear: { x: vx, y: vy, z: 0 },
        angular: { x: 0, y: 0, z: wz }
      });

      if (cmdVelInterval) {
        clearInterval(cmdVelInterval);
        cmdVelInterval = null;
      }

      cmdVelInterval = setInterval(() => {
        cmdVel.publish(twist);

        if (vx === 0 && vy === 0 && wz === 0) {
          // ğŸ›‘ Stop â†’ calcola durata
          if (startTime) {
            const endTime = Date.now();
            testDuration = (endTime - startTime) / 1000;
            document.getElementById('testDuration').innerText = `${testDuration.toFixed(2)} secondi`;
            startTime = null;
          }
          document.getElementById('calibOutput').innerText = `ğŸ›‘ Comando di stop inviato periodicamente`;
        } else {
          // ğŸš€ Inizio test
          startTime = Date.now();
          testDuration = null;
          document.getElementById('testDuration').innerText = `Test in corso...`;
          document.getElementById('calibOutput').innerText =
            `ğŸ“¤ Comando inviato: vx=${vx}, vy=${vy}, wz=${wz}`;
        }
      }, 100);
    }

    function sendCalibration() {
      const device = document.getElementById('deviceSelect').value;
      const testType = document.getElementById('testType').value;
      const errorValue = parseFloat(document.getElementById('errorValue').value);

      if (isNaN(errorValue)) {
        alert('âš ï¸ Inserisci un valore numerico valido per lâ€™errore.');
        return;
      }

      // â±ï¸ Verifica che il test sia stato eseguito e fermato
      if (!testDuration || testDuration <= 0) {
        alert('âš ï¸ Devi prima eseguire il test e premere STOP per calcolare la durata.');
        return;
      }

      // ğŸ“‰ Calcola errore normalizzato: velocitÃ  = errore / tempo
      const normalizedError = errorValue / testDuration;

      // ğŸ›°ï¸ Costruisce e invia la richiesta al servizio ROS
      const service = new ROSLIB.Service({
        ros: ros,
        name: `/run_calibration_test`,
        serviceType: 'mecanum_base/CalibrationInput'
      });

      const request = new ROSLIB.ServiceRequest({
        test_type: testType,
        error_value: normalizedError
      });

      service.callService(request, (result) => {
        document.getElementById('calibOutput').innerText = result.result;
      });
    }
  </script>
</body>
</html>